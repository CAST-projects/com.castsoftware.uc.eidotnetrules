<?xml version="1.0" encoding="utf-8"?>
<root>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="description">
    <english>This rule will check whether local variables are shadowing class fields.

In case of C#, classes as well as structs are considered.
In case of Visual Basic, modules also considered in addition to classes.

In case of classes, only non-private fields of Base classes are considered.</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="name">
    <english>Avoid local variables shadowing class fields</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code
- Bookmark to field that is being shadowed</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="rationale">
    <english>Both overriding or shadowing a class field (typically non-private)  can strongly impact the readability, and therefore the maintainability, of a piece of code.</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="reference">
    <english>CERT, DCL01-C. - Do not reuse variable names in subscopes
CERT, DCL51-J. - Do not shadow or obscure identifiers in subscopes</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="remediation">
    <english>Ensure you have an explicit way, usually in form of naming conventions, to name your local variable to avoid conflict with class fields.</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="remediationSample">
    <english>// Field Shadowing

class MyVector {
  private int val = 1;
  private void doLogic() {
    int newValue;
    //...
  }
}

// Variable Shadowing

class MyVector {
  private void doLogic() {
    for (int i = 0; i &lt; 10; i++) {/* ... */}
    for (int i = 0; i &lt; 20; i++) {/* ... */}
  }
}</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="sample">
    <english>// Field Shadowing

class MyVector {
  private int val = 1;
  private void doLogic() {
    int val;
    //...
  }
}

// Variable shadowing

class MyVector {
  private int i = 0;
  private void doLogic() {
    for (i = 0; i &lt; 10; i++) {/* ... */}
    for (int i = 0; i &lt; 20; i++) {/* ... */}
  }
}</english>
  </metric>
  <metric id="1118000" type="quality-rule" originalName="Avoid local variables shadowing class fields" section="total">
    <english>Number of Methods</english>
  </metric>
  <metric id="1118002" type="quality-rule" originalName="Child class fields should not shadow parent class fields" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1118002" type="quality-rule" originalName="Child class fields should not shadow parent class fields" section="name">
    <english>Child class fields should not shadow parent class fields</english>
  </metric>
  <metric id="1118002" type="quality-rule" originalName="Child class fields should not shadow parent class fields" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1118002" type="quality-rule" originalName="Child class fields should not shadow parent class fields" section="rationale">
    <english>Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you'll get confusion at best, chaos at worst.</english>
  </metric>
  <metric id="1118002" type="quality-rule" originalName="Child class fields should not shadow parent class fields" section="reference">
    <english>https://rules.sonarsource.com/csharp/RSPEC-2387</english>
  </metric>
  <metric id="1118002" type="quality-rule" originalName="Child class fields should not shadow parent class fields" section="remediationSample">
    <english>public class Fruit
{
  protected Season ripe;
  protected Color flesh;

  // ...
}

public class Raspberry : Fruit
{
  private bool ripened;
  private static Color FLESH_COLOR;
}</english>
  </metric>
  <metric id="1118002" type="quality-rule" originalName="Child class fields should not shadow parent class fields" section="sample">
    <english>public class Fruit
{
  protected Season ripe;
  protected Color flesh;

  // ...
}

public class Raspberry : Fruit
{
  private bool ripe; // Noncompliant
  private static Color FLESH; // Noncompliant
}</english>
  </metric>
  <metric id="1118004" type="quality-rule" originalName="Inherited member visibility should not be decreased" section="associatedValueName">
    <english>Number of violation occurrences</english>
  </metric>
  <metric id="1118004" type="quality-rule" originalName="Inherited member visibility should not be decreased" section="description">
    <english>This rule raises an issue when a private method in an unsealed type has a signature that is identical to a public method declared in a base type.</english>
  </metric>
  <metric id="1118004" type="quality-rule" originalName="Inherited member visibility should not be decreased" section="name">
    <english>Inherited member visibility should not be decreased</english>
  </metric>
  <metric id="1118004" type="quality-rule" originalName="Inherited member visibility should not be decreased" section="output">
    <english>Associated to each violation, the following information is provided:
- The number of violation occurrences
- Bookmarks for violation occurrences found in the source code</english>
  </metric>
  <metric id="1118004" type="quality-rule" originalName="Inherited member visibility should not be decreased" section="rationale">
    <english>Changing an inherited member to private will not prevent access to the base class implementation</english>
  </metric>
  <metric id="1118004" type="quality-rule" originalName="Inherited member visibility should not be decreased" section="reference">
    <english>https://rules.sonarsource.com/csharp/RSPEC-4015</english>
  </metric>
  <metric id="1118004" type="quality-rule" originalName="Inherited member visibility should not be decreased" section="remediationSample">
    <english>using System;

namespace MyLibrary
{
  public class Foo
  {
    public void SomeMethod(int count) { }
  }
  public sealed class Bar : Foo
  {
    private void SomeMethod(int count) { }
  }
}</english>
  </metric>
  <metric id="1118004" type="quality-rule" originalName="Inherited member visibility should not be decreased" section="sample">
    <english>using System;

namespace MyLibrary
{
  public class Foo
  {
    public void SomeMethod(int count) { }
  }
  public class Bar:Foo
  {
    private void SomeMethod(int count) { } // Noncompliant
  }
}</english>
  </metric>
</root>